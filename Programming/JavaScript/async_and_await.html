<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding async/await in JavaScript</title>
</head>
<body>
    <h1>Understanding async/await in JavaScript</h1>
    <p><code>async/await</code> is a modern way to handle asynchronous operations in JavaScript. It makes asynchronous code look and behave like synchronous code, improving readability and maintainability.</p>

    <h2>What is <code>async/await</code>?</h2>
    <p><code>async/await</code> is built on top of Promises. It allows you to write asynchronous code in a synchronous style without blocking the main thread.</p>
    <ul>
        <li><strong><code>async</code>:</strong> A keyword used to declare an asynchronous function. It automatically returns a Promise.</li>
        <li><strong><code>await</code>:</strong> A keyword used to pause the execution of an <code>async</code> function until a Promise is resolved or rejected.</li>
    </ul>

    <h2>Benefits of <code>async/await</code></h2>
    <ul>
        <li><strong>Readability:</strong> Code is easier to read and understand compared to nested callbacks or chained Promises.</li>
        <li><strong>Error Handling:</strong> Errors can be handled using <code>try/catch</code>, making it similar to synchronous error handling.</li>
        <li><strong>Debugging:</strong> Debugging is easier because the code looks synchronous.</li>
    </ul>

    <h2>Basic Syntax</h2>
    <pre>
        async function myFunction() {
            try {
                const result = await someAsyncOperation();
                console.log(result);
            } catch (error) {
                console.error(error);
            }
        }
    </pre>
    <p>In this example:</p>
    <ul>
        <li><code>async</code> declares the function as asynchronous.</li>
        <li><code>await</code> pauses the function execution until <code>someAsyncOperation()</code> completes.</li>
        <li><code>try/catch</code> is used to handle errors.</li>
    </ul>

    <h2>Example 1: Basic <code>async/await</code></h2>
    <p>Let's simulate an asynchronous operation using <code>setTimeout</code> and handle it with <code>async/await</code>.</p>
    <pre>
        async function fetchData() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve("Data fetched successfully!");
                }, 2000);
            });
        }

        async function main() {
            console.log("Fetching data...");
            const result = await fetchData();
            console.log(result);
        }

        main();
    </pre>
    <p><strong>Output:</strong></p>
    <pre>
        Fetching data...
        (After 2 seconds) Data fetched successfully!
    </pre>

    <h2>Example 2: Error Handling with <code>try/catch</code></h2>
    <p>Let's simulate an error in an asynchronous operation and handle it using <code>try/catch</code>.</p>
    <pre>
        async function fetchData() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const success = false; // Simulate an error
                    if (success) {
                        resolve("Data fetched successfully!");
                    } else {
                        reject("Error: Failed to fetch data!");
                    }
                }, 2000);
            });
        }

        async function main() {
            try {
                console.log("Fetching data...");
                const result = await fetchData();
                console.log(result);
            } catch (error) {
                console.error(error);
            }
        }

        main();
    </pre>
    <p><strong>Output:</strong></p>
    <pre>
        Fetching data...
        (After 2 seconds) Error: Failed to fetch data!
    </pre>

    <h2>Example 3: Chaining Multiple Asynchronous Operations</h2>
    <p>You can chain multiple asynchronous operations using <code>async/await</code>.</p>
    <pre>
        async function fetchData() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ id: 1, name: "John Doe" });
                }, 1000);
            });
        }

        async function processData(data) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    data.age = 30; // Add a new property
                    resolve(data);
                }, 1000);
            });
        }

        async function saveData(data) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    console.log("Data saved successfully:", data);
                    resolve("Data saved!");
                }, 1000);
            });
        }

        async function main() {
            try {
                const data = await fetchData();
                console.log("Data fetched:", data);

                const processedData = await processData(data);
                console.log("Data processed:", processedData);

                const message = await saveData(processedData);
                console.log(message);
            } catch (error) {
                console.error("Error:", error);
            }
        }

        main();
    </pre>
    <p><strong>Output:</strong></p>
    <pre>
        Data fetched: { id: 1, name: "John Doe" }
        (After 1 second) Data processed: { id: 1, name: "John Doe", age: 30 }
        (After 1 second) Data saved successfully: { id: 1, name: "John Doe", age: 30 }
        (After 1 second) Data saved!
    </pre>

    <h2>Example 4: Parallel Execution with <code>Promise.all</code></h2>
    <p>You can run multiple asynchronous operations in parallel using <code>Promise.all</code> with <code>async/await</code>.</p>
    <pre>
        async function fetchUser() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ id: 1, name: "John Doe" });
                }, 1000);
            });
        }

        async function fetchPosts() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(["Post 1", "Post 2"]);
                }, 1500);
            });
        }

        async function main() {
            try {
                const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);
                console.log("User:", user);
                console.log("Posts:", posts);
            } catch (error) {
                console.error("Error:", error);
            }
        }

        main();
    </pre>
    <p><strong>Output:</strong></p>
    <pre>
        (After 1.5 seconds)
        User: { id: 1, name: "John Doe" }
        Posts: ["Post 1", "Post 2"]
    </pre>

    <h2>Conclusion</h2>
    <p><code>async/await</code> is a powerful feature in JavaScript that simplifies asynchronous programming. It makes your code more readable, easier to debug, and allows you to handle errors more effectively using <code>try/catch</code>. By combining <code>async/await</code> with Promises, you can write clean and efficient asynchronous code.</p>

    <script>
        // Example 1: Basic async/await
        async function fetchData() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve("Data fetched successfully!");
                }, 2000);
            });
        }

        async function main1() {
            console.log("Fetching data...");
            const result = await fetchData();
            console.log(result);
        }

        main1();

        // Example 2: Error Handling with try/catch
        async function fetchDataWithError() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const success = false; // Simulate an error
                    if (success) {
                        resolve("Data fetched successfully!");
                    } else {
                        reject("Error: Failed to fetch data!");
                    }
                }, 2000);
            });
        }

        async function main2() {
            try {
                console.log("Fetching data...");
                const result = await fetchDataWithError();
                console.log(result);
            } catch (error) {
                console.error(error);
            }
        }

        main2();

        // Example 3: Chaining Multiple Asynchronous Operations
        async function fetchDataChain() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ id: 1, name: "John Doe" });
                }, 1000);
            });
        }

        async function processData(data) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    data.age = 30; // Add a new property
                    resolve(data);
                }, 1000);
            });
        }

        async function saveData(data) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    console.log("Data saved successfully:", data);
                    resolve("Data saved!");
                }, 1000);
            });
        }

        async function main3() {
            try {
                const data = await fetchDataChain();
                console.log("Data fetched:", data);

                const processedData = await processData(data);
                console.log("Data processed:", processedData);

                const message = await saveData(processedData);
                console.log(message);
            } catch (error) {
                console.error("Error:", error);
            }
        }

        main3();

        // Example 4: Parallel Execution with Promise.all
        async function fetchUser() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ id: 1, name: "John Doe" });
                }, 1000);
            });
        }

        async function fetchPosts() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(["Post 1", "Post 2"]);
                }, 1500);
            });
        }

        async function main4() {
            try {
                const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);
                console.log("User:", user);
                console.log("Posts:", posts);
            } catch (error) {
                console.error("Error:", error);
            }
        }

        main4();
    </script>
</body>
</html>